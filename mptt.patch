diff --git a/trytond/model/fields/many2one.py b/trytond/model/fields/many2one.py
--- a/trytond/model/fields/many2one.py
+++ b/trytond/model/fields/many2one.py
@@ -19,7 +19,7 @@ class Many2One(Field):
     _type = 'many2one'
     _sql_type = 'INTEGER'
 
-    def __init__(self, model_name, string='', left=None, right=None,
+    def __init__(self, model_name, string='', left=None, right=None, path=None,
             ondelete='SET NULL', datetime_field=None, target_search='join',
             search_order=None, search_context=None, help='', required=False,
             readonly=False, domain=None, states=None, select=False,
@@ -31,6 +31,7 @@ class Many2One(Field):
             Modified Preorder Tree Traversal.
             See http://en.wikipedia.org/wiki/Tree_traversal
         :param right: The name of the field to store the right value. See left
+        :param path: The name of the field to store the path.
         :param ondelete: Define the behavior of the record when the target
             record is deleted. (``CASCADE``, ``RESTRICT``, ``SET NULL``)
             ``SET NULL`` will be changed into ``RESTRICT`` if required is set.
@@ -56,6 +57,7 @@ class Many2One(Field):
         self.model_name = model_name
         self.left = left
         self.right = right
+        self.path = path
         self.datetime_field = datetime_field
         assert target_search in ['subquery', 'join']
         self.target_search = target_search
@@ -112,6 +114,27 @@ class Many2One(Field):
         assert value is not False
         return int(value)
 
+    def convert_domain_path(self, domain, tables):
+        cursor = Transaction().connection.cursor()
+        table, _ = tables[None]
+        name, operator, ids = domain
+        red_sql = reduce_ids(table.id, (i for i in ids if i is not None))
+        Target = self.get_target()
+        path_column = getattr(Target, self.path).sql_column(table)
+        cursor.execute(*table.select(path_column, where=red_sql))
+        if operator.endswith('child_of'):
+            where = Or()
+            for path, in cursor:
+                where.append(path_column.like(path + '%'))
+        else:
+            ids = [int(x) for path, in cursor for x in path.split('/')[:-1]]
+            where = reduce_ids(table.id, ids)
+        if not where:
+            where = Literal(False)
+        if operator.startswith('not'):
+            return ~where
+        return where
+
     def convert_domain_mptt(self, domain, tables):
         cursor = Transaction().connection.cursor()
         table, _ = tables[None]
@@ -200,6 +223,9 @@ class Many2One(Field):
                 elif self.left and self.right:
                     return self.convert_domain_mptt(
                         (name, operator, ids), tables)
+                elif self.path:
+                    return self.convert_domain_path(
+                        (name, operator, ids), tables)
                 else:
                     return self.convert_domain_tree(
                         (name, operator, ids), tables)
diff --git a/trytond/model/modelsql.py b/trytond/model/modelsql.py
--- a/trytond/model/modelsql.py
+++ b/trytond/model/modelsql.py
@@ -1,15 +1,15 @@
 # This file is part of Tryton.  The COPYRIGHT file at the top level of
 # this repository contains the full copyright notices and license terms.
 import datetime
-from itertools import islice, chain
+from itertools import islice, chain, repeat
 from collections import OrderedDict
 from functools import wraps
 
 from sql import (Table, Column, Literal, Desc, Asc, Expression, Null,
-    NullsFirst, NullsLast)
-from sql.functions import CurrentTimestamp, Extract
+    NullsFirst, NullsLast, With)
+from sql.functions import CurrentTimestamp, Extract, Substring
 from sql.conditionals import Coalesce
-from sql.operators import Or, And, Operator, Equal
+from sql.operators import Or, And, Operator, Equal, Concat
 from sql.aggregate import Count, Max
 
 from trytond.model import ModelStorage, ModelView
@@ -273,19 +273,32 @@ class ModelSQL(ModelStorage):
                 field_name, action=required and 'add' or 'remove')
 
         for field_name, field in cls._fields.items():
-            if isinstance(field, fields.Many2One) \
-                    and field.model_name == cls.__name__ \
-                    and field.left and field.right:
-                left_default = cls._defaults.get(field.left, lambda: None)()
-                right_default = cls._defaults.get(field.right, lambda: None)()
-                cursor.execute(*sql_table.select(sql_table.id,
-                        where=(Column(sql_table, field.left) == left_default)
-                        | (Column(sql_table, field.left) == Null)
-                        | (Column(sql_table, field.right) == right_default)
-                        | (Column(sql_table, field.right) == Null),
-                        limit=1))
-                if cursor.fetchone():
-                    cls._rebuild_tree(field_name, None, 0)
+            if (isinstance(field, fields.Many2One)
+                    and field.model_name == cls.__name__):
+                if field.path:
+                    default_path = cls._defaults.get(
+                        field.path, lambda: None)()
+                    cursor.execute(*sql_table.select(sql_table.id,
+                            where=(
+                                Column(sql_table, field.path) == default_path)
+                            | (Column(sql_table, field.path) == Null),
+                            limit=1))
+                    if cursor.fetchone():
+                        cls._rebuild_path(field_name)
+                if field.left and field.right:
+                    left_default = cls._defaults.get(
+                        field.left, lambda: None)()
+                    right_default = cls._defaults.get(
+                        field.right, lambda: None)()
+                    cursor.execute(*sql_table.select(sql_table.id,
+                            where=(
+                                Column(sql_table, field.left) == left_default)
+                            | (Column(sql_table, field.left) == Null)
+                            | (Column(sql_table, field.right) == right_default)
+                            | (Column(sql_table, field.right) == Null),
+                            limit=1))
+                    if cursor.fetchone():
+                        cls._rebuild_tree(field_name, None, 0)
 
         for ident, constraint, _ in cls._sql_constraints:
             table.add_constraint(ident, constraint)
@@ -617,6 +630,11 @@ class ModelSQL(ModelStorage):
         transaction.create_records.setdefault(cls.__name__,
             set()).update(new_ids)
 
+        # Update path before fields_to_set which could create children
+        if cls._path_fields:
+            field_names = list(sorted(cls._path_fields))
+            cls._set_path(field_names, repeat(new_ids, len(field_names)))
+
         translation_values = {}
         fields_to_set = {}
         for values, new_id in zip(vlist, new_ids):
@@ -986,6 +1004,11 @@ class ModelSQL(ModelStorage):
                 if hasattr(field, 'set'):
                     fields_to_set.setdefault(fname, []).extend((ids, value))
 
+            path_fields = cls._path_fields & values.keys()
+            if path_fields:
+                cls._update_path(
+                    list(sorted(path_fields)), repeat(ids, len(path_fields)))
+
             field_names = list(values.keys())
             cls._update_mptt(field_names, [ids] * len(field_names), values)
             all_field_names |= set(field_names)
@@ -1366,6 +1389,76 @@ class ModelSQL(ModelStorage):
         return tables, expression
 
     @classmethod
+    def _rebuild_path(cls, field_name):
+        "Rebuild path for the tree."
+        cursor = Transaction().connection.cursor()
+        field = cls._fields[field_name]
+        table = cls.__table__()
+        tree = With('id', 'path', recursive=True)
+        tree.query = table.select(
+            table.id, Concat(table.id, '/'),
+            where=Column(table, field_name) == Null)
+        tree.query |= (table
+            .join(tree,
+                conditions=Column(table, field_name) == tree.id)
+            .select(table.id, Concat(Concat(tree.path, table.id), '/')))
+        query = table.update(
+            [Column(table, field.path)],
+            [tree.path],
+            from_=[tree], where=table.id == tree.id,
+            with_=[tree])
+        cursor.execute(*query)
+
+    @classmethod
+    def _set_path(cls, field_names, list_ids):
+        cursor = Transaction().connection.cursor()
+        table = cls.__table__()
+        parent = cls.__table__()
+        for field_name, ids in zip(field_names, list_ids):
+            field = cls._fields[field_name]
+            parent_column = Column(table, field_name)
+            path_column = Column(table, field.path)
+            query = table.update(
+                [path_column],
+                [Concat(Concat(Coalesce(
+                                parent.select(parent.path,
+                                    where=parent.id == parent_column),
+                                ''), table.id), '/')])
+            for sub_ids in grouped_slice(ids):
+                query.where = reduce_ids(table.id, sub_ids)
+                cursor.execute(*query)
+
+    @classmethod
+    def _update_path(cls, field_names, list_ids):
+        transaction = Transaction()
+        cursor = transaction.connection.cursor()
+        update = transaction.connection.cursor()
+        table = cls.__table__()
+        parent = cls.__table__()
+        for field_name, ids in zip(field_names, list_ids):
+            field = cls._fields[field_name]
+            parent_column = Column(table, field_name)
+            parent_path_column = Column(parent, field.path)
+            path_column = Column(table, field.path)
+            query = (table
+                .join(parent, 'LEFT',
+                    condition=parent_column == parent.id)
+                .select(path_column,
+                    Concat(Concat(
+                            Coalesce(parent_path_column, ''), table.id), '/')))
+            for sub_ids in grouped_slice(ids):
+                query.where = reduce_ids(table.id, sub_ids)
+                cursor.execute(*query)
+                for old_path, new_path in cursor:
+                    if old_path == new_path:
+                        continue
+                    update.execute(*table.update(
+                            [path_column],
+                            [Concat(new_path,
+                                    Substring(table.path, len(old_path) + 1))],
+                            where=table.path.like(old_path + '%')))
+
+    @classmethod
     def _update_mptt(cls, field_names, list_ids, values=None):
         cursor = Transaction().connection.cursor()
         for field_name, ids in zip(field_names, list_ids):
diff --git a/trytond/model/modelstorage.py b/trytond/model/modelstorage.py
--- a/trytond/model/modelstorage.py
+++ b/trytond/model/modelstorage.py
@@ -82,6 +82,16 @@ class ModelStorage(Model):
                     })
         cls._constraints = []
 
+    @classmethod
+    def __post_setup__(cls):
+        super().__post_setup__()
+        cls._path_fields = set()
+        for name, field in cls._fields.items():
+            if (isinstance(field, fields.Many2One)
+                    and field.model_name == cls.__name__):
+                if field.path:
+                    cls._path_fields.add(name)
+
     @staticmethod
     def default_create_uid():
         "Default value for uid field."
